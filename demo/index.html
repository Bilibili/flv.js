<!DOCTYPE html>
<html>

<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <title>flv.js demo</title>
    <link rel="stylesheet" type="text/css" href="demo.css" />
</head>

<body>
    
    <div class="mainContainer">
        <div>
            <div id="streamURL">
                <div class="url-input">
                    <label for="sURL">Stream URL:</label>
                    <input id="sURL" type="text" value="http://172.30.13.52:8080/wick2.flv" />
                    <button onclick="switch_mds()">Switch to MediaDataSource</button>
                </div>
                <div class="options">
                    <input type="checkbox" id="isLive" onchange="saveSettings()" />
                    <label for="isLive">isLive</label>
                    <input type="checkbox" id="withCredentials" onchange="saveSettings()" />
                    <label for="withCredentials">withCredentials</label>
                    <input type="checkbox" id="hasAudio" onchange="saveSettings()" checked />
                    <label for="hasAudio">hasAudio</label>
                    <input type="checkbox" id="hasVideo" onchange="saveSettings()" checked />
                    <label for="hasVideo">hasVideo</label>
                </div>
            </div>
            <div id="mediaSourceURL" class="hidden">
                <div class="url-input">
                    <label for="msURL">MediaDataSource JsonURL:</label>
                    <input id="msURL" type="text" value="http://172.30.13.52:8080/wick2.flv" />
                    <button onclick="switch_url()">Switch to URL</button>
                </div>
            </div>
        </div>
        <div class="video-container">
            <div>
                <video name="videoElement" class="centeredVideo" loop controls autoplay width="60" height="40">
                    Your browser is too old which doesn't support HTML5 video.
                </video>
                <div>
                <canvas id="canvas" width="1000" height="1500"></canvas>
                    <div>
                        <input type="checkbox" name="show_original" checked hidden>
                        <table>

                            <tr>
                                <td>azimuth</td><td><input type="range" min="0" max="360" value="0" class="slider" name="azimuth" style="width:400px"><output name="azimuth_output">0</output></td>
                            </tr>
                            <tr>
                                <td>lens</td><td><input type="range" min="0" max="2000" value="110" class="slider" name="lens_factor" style="width:400px"><output name="lens_factor_output">1.1</output></td>
                            </tr>
                            <tr>
                                <td>distance</td><td><input type="range" min="0" max="1000" value="500" class="slider" name="front_clip" style="width:400px"><output name="front_clip_output">0.0</output></td>
                            </tr>
                            <tr>
                                <td>fov</td><td><input type="range" min="0" max="360" value="90" class="slider" name="fov" style="width:400px"><output name="fov_output">90</output></td>
                            </tr>
                            <tr>
                                <td>radius</td><td><input type="range" min="0" max="1200" value="500" class="slider" name="outer_radius" style="width:400px"><output name="outer_radius_output">0.5</output></td>
                            </tr>
                            <tr>
                                <td>lens aspect ratio</td><td><input type="range" min="500" max="2000" value="1000" class="slider" name="lens_aspect" style="width:400px"><output name="lens_aspect_output">1.0</output></td>
                            </tr>
                            <tr>
                                <td>output scale Y</td><td><input type="range" min="0" max="1000" value="1000" class="slider" name="output_scale" style="width:400px"><output name="output_scale_output">1.0</output></td>
                            </tr>
                            <tr>
                                <td>output scale X</td><td><input type="range" min="0" max="1000" value="1000" class="slider" name="output_scale_x" style="width:400px"><output name="output_scale_output_x">1.0</output></td>
                            </tr>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        <div class="controls">
            <button onclick="flv_load()">Load</button>
            <button onclick="flv_start()">Start</button>
            <button onclick="flv_pause()">Pause</button>
            <button onclick="flv_destroy()">Destroy</button>
            <input style="width:100px" type="text" name="seekpoint"/>
            <button onclick="flv_seekto()">SeekTo</button>
        </div>
        <textarea name="logcatbox" class="logcatBox" rows="10" readonly></textarea>
    </div>

    <script src="../dist/flv.js"></script>
    <script src="gl-matrix.js"></script>
    
    <script>
        var checkBoxFields = ['isLive', 'withCredentials', 'hasAudio', 'hasVideo'];
        var streamURL, mediaSourceURL;

        var processor = {
            timerCallback: function() {
                if (this.video.paused || this.video.ended) {
                    return;
                }
                this.computeFrame();
                var self = this;
                setTimeout(function () {
                    self.timerCallback();
                }, 1); // roughly 60 frames per second
            },

            initShaderProgram: function(gl, vsSource, fsSource) {
                const vertexShader = this.loadShader(gl, gl.VERTEX_SHADER, vsSource);
                const fragmentShader = this.loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

                // Create the shader program

                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);

                // If creating the shader program failed, alert

                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                    return null;
                }

                return shaderProgram;
            },

            initBuffers: function(gl) {
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);


                var width = 1.7;
                var height = 2.0;
                var halfw = width/2.0;
                var halfh = height/2.0;

                const positions = [ -halfw, -halfh, 1.0,
                0.0, -halfh, 1.0,
                0.0, halfh, 1.0,
                halfw, -halfh, 1.0,
                halfw, halfh, 1.0,
                -halfw, halfh, 1.0];
//
//                const positions = [
//                    // Front face
//                    -1.0, -1.0,  1.0, // BL
//                    0.0, -1.0,  1.0, // MB
//                    0.0, 1.0,  1.0, // MT
//                    1.0, -1.0,  1.0, // BR
//                    1.0, 1.0,  1.0, // TR
//                    -1.0, 1.0,  1.0  // TL
//                ];


                const indices = [
                    0, 1, 2,
                    0, 2, 5,
                    2, 1, 3,
                    2, 4, 3

                ];

                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

                const textureCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);


                const textureCoordinates = [0, 0,
                    0.5, 0,
                    0.5, 1,
                    1, 0,
                    1, 1,
                    0, 1];//[-0.5, -0.5, 0, -0.5, 0, 0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5];

                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates),
                    gl.STATIC_DRAW);

                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);


                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                    new Uint16Array(indices), gl.STATIC_DRAW);

                return {
                    position: positionBuffer,
                    textureCoord: textureCoordBuffer,
                    indices: indexBuffer,
                };
            },

            //
            // Initialize a texture.
            //
            initTexture: function(gl, url) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                const level = 0;
                const internalFormat = gl.RGBA;
                const width = 1;
                const height = 1;
                const border = 0;
                const srcFormat = gl.RGBA;
                const srcType = gl.UNSIGNED_BYTE;
                const pixel = new Uint8Array([0, 0, 255, 255]);  // opaque blue
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                    width, height, border, srcFormat, srcType,
                    pixel);

                // Turn off mips and set  wrapping to clamp to edge so it
                // will work regardless of the dimensions of the video.
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                return texture;
            },

            initTransparentTexture: function(gl, url) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                const level = 0;
                const internalFormat = gl.RGBA;
                const width = 1;
                const height = 1;
                const border = 0;
                const srcFormat = gl.RGBA;
                const srcType = gl.UNSIGNED_BYTE;
                const pixel = new Uint8Array([255, 255, 255, 60]);  // opaque blue
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                    width, height, border, srcFormat, srcType,
                    pixel);

                // Turn off mips and set  wrapping to clamp to edge so it
                // will work regardless of the dimensions of the video.
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                return texture;
            },

            //
            // copy the video texture
            //
            updateTexture: function(gl, texture, video) {
                const level = 0;
                const internalFormat = gl.RGBA;
                const srcFormat = gl.RGBA;
                const srcType = gl.UNSIGNED_BYTE;
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                    srcFormat, srcType, video);
            },

            isPowerOf2: function(value) {
                return (value & (value - 1)) == 0;
            },

            loadShader: function(gl, type, source) {
                const shader = gl.createShader(type);

                // Send the source to the shader object

                gl.shaderSource(shader, source);

                // Compile the shader program

                gl.compileShader(shader);

                // See if it compiled successfully

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            },

            refreshVariables: function(gl) {

                if (!this.azimuth_override)
                    this.azimuth = document.getElementsByName('azimuth')[0].value * 0.0174533;
                this.lens_factor = document.getElementsByName('lens_factor')[0].value / 1000.0;
                this.lens_aspect = document.getElementsByName('lens_aspect')[0].value / 1000.0;
                this.front_clip = document.getElementsByName('front_clip')[0].value / 1000.0 - 0.5;
                this.fov = document.getElementsByName('fov')[0].value * 0.0174533;
                this.outer_radius = document.getElementsByName('outer_radius')[0].value / 1000.0;
                this.show_original = document.getElementsByName('show_original')[0].checked;
                this.y_scale = document.getElementsByName('output_scale')[0].value / 1000.0;
                this.x_scale = document.getElementsByName('output_scale_x')[0].value / 1000.0;


//                var canvas = document.createElement('canvas');
//                canvas.width = this.video.videoWidth;
//                canvas.height = this.video.videoHeight;
//                var context = canvas.getContext('2d');
//
//                context.drawImage(this.video, 0, 0);
//                console.log(canvas.toDataURL("image/png"));
//                if (this.video.videoWidth > 0) {
//
//                    var theData = context.getImageData(0, 0, this.video.videoWidth, this.video.videoHeight);
//
//
//                    var x = 0;
//                    var y = 300;
//
//                    var getLuminosity = function(data, x, y) {
//                        var idx = (i + y * this.video.videoWidth) * 4;
//                        var red = theData.data[idx + 0];
//                        var green = theData.data[idx + 1];
//                        var blue = theData.data[idx + 2];
//                        var alpha = theData.data[idx + 3];
//
//                        return (red + green + blue) / 255 * 3;
//                    }
//
//                    for (var i = 0; i < this.video.videoWidth/2.0; i++) {
//                        var lumin = getLuminosity(theData.data, )
//                        console.log("Color: X: " + i + " Y: " + y + "(" + red + "," + green + "," + blue + "," + alpha + ")");
//                    }
//                }


                this.near_width = this.lens_factor;

//                this.frustum = [
//                    (this.near_center_x - this.norm_x * this.near_hwidth + 0.5), (this.near_center_y - this.norm_y * this.near_hwidth + 0.5),// bottom left
//                    (this.near_center_x + 0.5), (this.near_center_y + 0.5),// bottom left
//                    (this.far_center_x + 0.5), (this.far_center_y + 0.5),// bottom left
//                    (this.near_center_x + this.norm_x * this.near_hwidth + 0.5), (this.near_center_y + this.norm_y * this.near_hwidth + 0.5),// bottom right
//                    (this.far_center_x + this.norm_x * this.far_hwidth + 0.5), (this.far_center_y + this.norm_y * this.far_hwidth + 0.5),// top right
//                    (this.far_center_x - this.norm_x * this.far_hwidth + 0.5), (this.far_center_y - this.norm_y * this.far_hwidth + 0.5),
//                ];

                this.frustum = [0, 0,
                0.5, 0,
                0.5, 1,
                1, 0,
                1, 1,
                0, 1];

                //this.frustum = [-0.5, -0.5, 0, -0.5, 0, 0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5];

                this.extents = [this.nearw, this.start_dist, this.farw, this.end_dist]


                this.frustum_positions = [
                    (this.near_center_x + this.norm_x * this.near_hwidth + 0.5), (this.near_center_y + this.norm_y * this.near_hwidth + 0.5), 1,// bottom right
                    (this.near_center_x + 0.5), (this.near_center_y + 0.5), 1,// mid bottom
                    (this.far_center_x + 0.5), (this.far_center_y + 0.5), 1,// mid top
                    (this.near_center_x - this.norm_x * this.near_hwidth + 0.5), (this.near_center_y - this.norm_y * this.near_hwidth + 0.5), 1,// bottom left
                    (this.far_center_x - this.norm_x * this.far_hwidth + 0.5), (this.far_center_y - this.norm_y * this.far_hwidth + 0.5), 1,// top right
                    (this.far_center_x + this.norm_x * this.far_hwidth + 0.5), (this.far_center_y + this.norm_y * this.far_hwidth + 0.5), 1
                ];


                if (!this.frustum_verts)
                    this.frustum_verts = gl.createBuffer();

                gl.bindBuffer(gl.ARRAY_BUFFER, this.frustum_verts);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.frustum), gl.STATIC_DRAW);

                if (!this.frustum_vert_pos)
                    this.frustum_vert_pos = gl.createBuffer()

                gl.bindBuffer(gl.ARRAY_BUFFER, this.frustum_vert_pos);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.frustum_positions), gl.STATIC_DRAW);


                //console.log(this.frustum);
                //console.log(this.frustum_positions);
            },

            doLoad: function() {


                document.onkeydown = checkKey;
                var self = this;
                function checkKey(e) {

                    e = e || window.event;

                    if (e.keyCode == '38') {
                        // up arrow
                        document.getElementsByName('front_clip')[0].value = document.getElementsByName('front_clip')[0].value + 1;
                        self.refreshVariables(self.gl);
                    }
                    else if (e.keyCode == '40') {
                        // down arrow
                        document.getElementsByName('front_clip')[0].value = document.getElementsByName('front_clip')[0].value - 1;
                        self.refreshVariables(self.gl);
                    }
                    else if (e.keyCode == '37') {
                        document.getElementsByName('azimuth')[0].value = document.getElementsByName('azimuth')[0].value - 1;
                        self.refreshVariables(self.gl);
                        console.log("left");
                    }
                    else if (e.keyCode == '39') {
                        // right arrow
                        document.getElementsByName('azimuth')[0].value = document.getElementsByName('azimuth')[0].value + 1;
                        console.log("right " + document.getElementsByName('azimuth')[0].value);
                        self.refreshVariables(self.gl);
                    }

                }
                this.video = document.getElementsByName("videoElement")[0];
                this.c1 = document.getElementById("canvas");
                this.gl = this.c1.getContext('webgl');

                const gl = this.gl;
                const vsSource = `
                    attribute vec4 aVertexPosition;
                    attribute vec3 aVertexNormal;
                    attribute vec2 aTextureCoord;
                    uniform mat4 uNormalMatrix;
                    uniform mat4 uModelViewMatrix;
                    uniform mat4 uProjectionMatrix;
                    uniform vec4 extents;
                    uniform highp float azimuth;

                    varying highp vec2 vTextureCoord;
                    varying highp vec3 vLighting;
                    void main(void) {
                      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                      vTextureCoord = aTextureCoord;
                    }
                  `;

                                // Fragment shader program

                                const fsSource = `
varying highp vec2 vTextureCoord;
 uniform sampler2D uSampler;
 uniform highp float azimuth;
 uniform highp float lens_factor;
 uniform highp float lens_aspect_ratio;
 uniform highp float front_clip;
 uniform highp float near_width;
 uniform highp float fov;
 uniform highp float outer_radius;
 uniform bool show_original;
 uniform bool draw_debug;

highp vec4 drawCircle(in highp vec2 center, in highp float radius, in highp vec2 uv, in highp vec4 circleColor, in highp vec4 color) {
   highp float result = length(uv-center);
    if (result - radius < 0.001 && result - radius > - 0.001) {
        return circleColor;
    } else {
        return color;
    }
}

highp vec4 drawLine(in highp vec2 a, in highp vec2 b, in highp vec2 c, in highp vec4 color) {
    highp float res;
    res = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);
    if(res < 0.001 && res > -0.001) {
        return vec4(1.0, 0, 0, 1.0);
    } else{
        return color;
    }
}

highp vec2 rotate(in vec2 vec, in highp float radians) {
    highp vec2 dir = vec2(sin(radians), cos(radians));

    return vec2(vec.x * dir.y - vec.y * dir.x, vec.x * dir.x + vec.y * dir.y);
}

highp vec2 sphereIntersect( in vec2 rayOrigin, in vec2 rayDirection, highp float radius, in vec2 center )
{
    highp vec2 oc = rayOrigin-center;
    highp float b = dot( oc, rayDirection );
    highp float c = dot( oc, oc ) - radius*radius;
    highp float h = b*b - c;
    if( h<0.0 ) return vec2(-1.0); // no intersection
    h = sqrt( h );
    return vec2( -b-h, -b+h );
}

void main(void)
{
	highp vec2 uv = vTextureCoord;;

    bool flip = false;
    highp float aspect_ratio = lens_aspect_ratio;
    highp vec2 dir = vec2(sin(azimuth), cos(azimuth)); // calculate a direction based on given azimuth
    highp vec2 pos = vec2(0.5, 0.5); // calculate center of our frustum
    highp float radius = (lens_factor/2.0) + ((near_width*near_width) / (8.0 * lens_factor)); // calculate our inner circle radius based on lensing
    // this allows us to change the lens aperature without moving the near clip which is crucial for tweaking values

    highp vec2 rStart = normalize(rotate(dir, -fov/2.0)); // left most near frustum point
    highp vec2 lStart = normalize(rotate(dir, fov/2.0)); // right most near frustum point
    highp vec2 lpos = pos + dir * (front_clip-radius);

    highp vec2 nearPlane = rStart-lStart; // Vector from left to right near plane points
    highp vec2 pixelDir = normalize(rotate(lStart, -fov * uv.x)); // Direction of ray that this pixel will interpolate from
    // this is interpolted along the uv.x, meaning the bottom left of the image will be at the left near frustum
    //and bottom right will be at the right near

        highp vec2 rayStart = lpos + pixelDir * radius; // multiply the direction by the radius of the inner frustum and offset by position
    highp vec2 rayEnd = lpos + pixelDir * sphereIntersect(lpos, pixelDir * 1.0, outer_radius, vec2(0.5, 0.5)).y; // find distance to outer frustum and clip our ray to this point
    highp vec2 res;

    if (flip) // ground mounted cameras will have their images flipped vertically
        res = mix(rayEnd, rayStart, uv.y);
    else
        res = mix(rayStart, rayEnd, uv.y);

    res.x -= 0.5;
    res.x *= 1.0/aspect_ratio; //our result coordinates need to have the inverse aspect ratio correction applied
    res.x += 0.5;

    if (show_original) {
    	uv.x -= 0.5;
        uv.x *= aspect_ratio;
        uv.x += 0.5;
        res = vTextureCoord;
    }


    highp vec4 color = texture2D(uSampler, res);
    if (res.x > 1.0 || res.y > 1.0)
        color = vec4(0.0, 0.0, 0.0, 1.0);
    if (draw_debug) { // this shits nasty af
        highp vec2 leftFar = sphereIntersect(lpos, lpos + lStart * outer_radius, outer_radius, vec2(0.5, 0.5));
        highp vec2 rightFar = sphereIntersect(lpos, lpos + rStart * outer_radius, outer_radius, vec2(0.5, 0.5));
        color = drawCircle(vec2(0.5, 0.5), outer_radius, uv, vec4(1.0, 0.0, 0.0, 1.0), color);
        color = drawCircle(lpos, radius, uv, vec4(1.0, 0.0, 0.0, 1.0), color);
        color = drawCircle(lpos+ lStart * radius, 0.01, uv, vec4(1.0, 1.0, 0.0, 1.0), color);
        color = drawCircle(lpos+ rStart * radius, 0.01, uv, vec4(1.0, 0.0, 1.0, 1.0), color);
        color = drawCircle(lpos + lStart * leftFar.y, 0.01, uv, vec4(1.0, 1.0, 0.0, 1.0), color);
        color = drawCircle(lpos + rStart * rightFar.y, 0.01, uv, vec4(1.0, 0.0, 1.0, 1.0), color);
        color = drawLine(lpos, lpos + lStart * leftFar.y, uv, color);
        color = drawLine(lpos, lpos + rStart * leftFar.y, uv, color);
    }

    gl_FragColor = color;
}`;

                // Initialize a shader program; this is where all the lighting
                // for the vertices and so forth is established.
                this.shaderProgram = this.initShaderProgram(gl, vsSource, fsSource);

                // Collect all the info needed to use the shader program.
                // Look up which attributes our shader program is using
                // for aVertexPosition, aVertexNormal, aTextureCoord,
                // and look up uniform locations.
                this.programInfo = {
                    program: this.shaderProgram,
                    attribLocations: {
                        vertexPosition: gl.getAttribLocation(this.shaderProgram, 'aVertexPosition'),
                        textureCoord: gl.getAttribLocation(this.shaderProgram, 'aTextureCoord'),
                    },
                    uniformLocations: {
                        projectionMatrix: gl.getUniformLocation(this.shaderProgram, 'uProjectionMatrix'),
                        modelViewMatrix: gl.getUniformLocation(this.shaderProgram, 'uModelViewMatrix'),
                        normalMatrix: gl.getUniformLocation(this.shaderProgram, 'uNormalMatrix'),
                        uSampler: gl.getUniformLocation(this.shaderProgram, 'uSampler'),
                        lens_factor: gl.getUniformLocation(this.shaderProgram, 'lens_factor'),
                        lens_aspect: gl.getUniformLocation(this.shaderProgram, 'lens_aspect_ratio'),
                        azimuth: gl.getUniformLocation(this.shaderProgram, 'azimuth'),
                        near_width: gl.getUniformLocation(this.shaderProgram, 'near_width'),
                        front_clip: gl.getUniformLocation(this.shaderProgram, 'front_clip'),
                        outer_radius: gl.getUniformLocation(this.shaderProgram, 'outer_radius'),
                        show_orig: gl.getUniformLocation(this.shaderProgram, 'show_original'),
                        draw_debug: gl.getUniformLocation(this.shaderProgram, 'draw_debug'),
                        fov: gl.getUniformLocation(this.shaderProgram, 'fov')

                    },
                };

                // Here's where we call the routine that builds all the
                // objects we'll be drawing.
                this.buffers = this.initBuffers(gl);

                this.texture = this.initTexture(gl);
                this.transparent_texture = this.initTransparentTexture(gl);

                this.refreshVariables(this.gl);
                var self = this;
                document.getElementsByName('azimuth')[0].addEventListener('input', function(e) {
                    document.getElementsByName('azimuth_output')[0].value = e.target.value;
                    self.refreshVariables(self.gl);
                });
                document.getElementsByName('lens_factor')[0].addEventListener('input', function(e) {
                    document.getElementsByName('lens_factor_output')[0].value = e.target.value/1000.0;
                    self.refreshVariables(self.gl);
                });

                document.getElementsByName('lens_aspect')[0].addEventListener('input', function(e) {
                    document.getElementsByName('lens_aspect_output')[0].value = e.target.value/1000.0;
                    self.refreshVariables(self.gl);
                });
                document.getElementsByName('front_clip')[0].addEventListener('input', function(e) {
                    document.getElementsByName('front_clip_output')[0].value = e.target.value / 1000.0;
                    self.refreshVariables(self.gl);
                });
                document.getElementsByName('fov')[0].addEventListener('input', function(e) {
                    document.getElementsByName('fov_output')[0].value = e.target.value;
                    self.refreshVariables(self.gl);
                });
                document.getElementsByName('outer_radius')[0].addEventListener('input', function(e) {
                    document.getElementsByName('outer_radius_output')[0].value = e.target.value/1000.0;
                    self.refreshVariables(self.gl);
                });

                document.getElementsByName('output_scale')[0].addEventListener('input', function(e) {
                    document.getElementsByName('output_scale_output')[0].value = e.target.value/1000.0;
                    self.refreshVariables(self.gl);
                });

                document.getElementsByName('output_scale_x')[0].addEventListener('input', function(e) {
                    document.getElementsByName('output_scale_output_x')[0].value = e.target.value/1000.0;
                    self.refreshVariables(self.gl);
                });

                document.getElementsByName('show_original')[0].addEventListener('input', function() {
                    self.refreshVariables(self.gl);
                });

                self.mouse_down = false;

                this.c1.addEventListener("mousedown", function(e) {
                    self.mouse_down = true;
                }, false);

                this.c1.addEventListener("mouseup", function(e) {
                   self.mouse_down = false;
                });

                this.c1.addEventListener("mousemove", function(e)
                {
                    if (!self.mouse_down)
                        return;



                    var x = event.x;
                    var y = event.y;

                    var canvas = document.getElementById("canvas");
                    var rect = canvas.getBoundingClientRect();
                    var midx = canvas.width;
                    var midy = canvas.height;

                    x -= rect.left;
                    y -= rect.top;

                    x = (x / canvas.width) - 0.5;
                    y = (1 - (y / canvas.height)) * 2.0 - 0.5;

                    self.azimuth_override = true;
                    self.azimuth = Math.atan2(x, y);

                    //console.log("x:" + x + " y:" + y);
                }, false);



                this.video.addEventListener("play", function() {
                    self.width = self.video.width;
                    self.height = self.video.height;
                    self.timerCallback();
                }, false);
            },

            computeFrame: function() {
                this.updateTexture(this.gl, this.texture, this.video);

                const gl = this.gl;
                gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
                gl.clearDepth(1.0);                 // Clear everything
                gl.enable(gl.DEPTH_TEST);           // Enable depth testing
                gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                // Clear the canvas before we start drawing on it.

                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // Create a perspective matrix, a special matrix that is
                // used to simulate the distortion of perspective in a camera.
                // Our field of view is 45 degrees, with a width/height
                // ratio that matches the display size of the canvas
                // and we only want to see objects between 0.1 units
                // and 100 units away from the camera.

                const fieldOfView = 45 * Math.PI / 180;   // in radians
                const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                const zNear = 0.1;
                const zFar = 100.0;
                const projectionMatrix = mat4.create();

                // note: glmatrix.js always has the first argument
                // as the destination to receive the result.

                mat4.ortho(projectionMatrix, -1.0, 1.0, -1, 1, 0.1, 100);

                // Set the drawing position to the "identity" point, which is
                // the center of the scene.
                modelViewMatrix = mat4.create();

                // Now move the drawing position a bit to where we want to
                // start drawing the square.
                const cubeRotation = 0;
                mat4.translate(modelViewMatrix,     // destination matrix
                    modelViewMatrix,     // matrix to translate
                    [0.0, -0.5, -2.0]);  // amount to translate
                const normalMatrix = mat4.create();

                mat4.scale(modelViewMatrix, modelViewMatrix, [1.0, 0.5, 0.5]);

                mat4.invert(normalMatrix, modelViewMatrix);
                mat4.transpose(normalMatrix, normalMatrix);

                // Tell WebGL how to pull out the positions from the position
                // buffer into the vertexPosition attribute
                {
                    const numComponents = 3;
                    const type = gl.FLOAT;
                    const normalize = false;
                    const stride = 0;
                    const offset = 0;
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.position);
                    gl.vertexAttribPointer(
                        this.programInfo.attribLocations.vertexPosition,
                        numComponents,
                        type,
                        normalize,
                        stride,
                        offset);
                    gl.enableVertexAttribArray(
                        this.programInfo.attribLocations.vertexPosition);
                }

                // Tell WebGL how to pull out the texture coordinates from
                // the texture coordinate buffer into the textureCoord attribute.
                {
                    const numComponents = 2;
                    const type = gl.FLOAT;
                    const normalize = false;
                    const stride = 0;
                    const offset = 0;
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.textureCoord);
                    gl.vertexAttribPointer(
                        this.programInfo.attribLocations.textureCoord,
                        numComponents,
                        type,
                        normalize,
                        stride,
                        offset);
                    gl.enableVertexAttribArray(
                        this.programInfo.attribLocations.textureCoord);
                }


                // Tell WebGL which indices to use to index the vertices
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.indices);

                // Tell WebGL to use our program when drawing

                gl.useProgram(this.programInfo.program);

                // Set the shader uniforms

                gl.uniformMatrix4fv(
                    this.programInfo.uniformLocations.projectionMatrix,
                    false,
                    projectionMatrix);
                gl.uniformMatrix4fv(
                    this.programInfo.uniformLocations.modelViewMatrix,
                    false,
                    modelViewMatrix);
                gl.uniformMatrix4fv(
                    this.programInfo.uniformLocations.normalMatrix,
                    false,
                    normalMatrix);

                gl.uniform1f(this.programInfo.uniformLocations.azimuth, this.azimuth);
                gl.uniform1f(this.programInfo.uniformLocations.lens_factor,  this.lens_factor);
                gl.uniform1f(this.programInfo.uniformLocations.lens_aspect, this.lens_aspect);
                gl.uniform1f(this.programInfo.uniformLocations.front_clip, this.front_clip);
                gl.uniform1f(this.programInfo.uniformLocations.near_width, this.near_width);
                gl.uniform1f(this.programInfo.uniformLocations.outer_radius, this.outer_radius);
                gl.uniform1i(this.programInfo.uniformLocations.show_orig, 1);
                gl.uniform1i(this.programInfo.uniformLocations.draw_debug, 1);
                gl.uniform1f(this.programInfo.uniformLocations.fov, this.fov);

                // Specify the texture to map onto the faces.

                // Tell WebGL we want to affect texture unit 0
                gl.activeTexture(gl.TEXTURE0);

                // Bind the texture to texture unit 0
                gl.bindTexture(gl.TEXTURE_2D, this.texture);

                // Tell the shader we bound the texture to texture unit 0
                gl.uniform1i(this.programInfo.uniformLocations.uSampler, 0);

                {
                    const vertexCount = 6;
                    const type = gl.UNSIGNED_SHORT;
                    const offset = 0;


                    gl.drawElements(gl.TRIANGLES, 12, type, offset);
                    modelViewMatrix = mat4.create();
                    mat4.translate(modelViewMatrix,     // destination matrix
                        modelViewMatrix,     // matrix to translate
                        [0.0, 0.5 , -2.0]);  // amount to translate

                    mat4.scale(modelViewMatrix, modelViewMatrix, [1.0*this.x_scale, 0.5*this.y_scale, 0.5]);
                    gl.uniform1i(this.programInfo.uniformLocations.show_orig, 0);
                    gl.uniform1i(this.programInfo.uniformLocations.draw_debug, 0);

                    const normalMatrix = mat4.create();

                    mat4.invert(normalMatrix, modelViewMatrix);
                    gl.uniformMatrix4fv(
                        this.programInfo.uniformLocations.modelViewMatrix,
                        false,
                        modelViewMatrix);

                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.textureCoord);
                    gl.vertexAttribPointer(
                        this.programInfo.attribLocations.textureCoord,
                        2,
                        gl.FLOAT,
                        false,
                        0,
                        0);
                    gl.enableVertexAttribArray(
                        this.programInfo.attribLocations.textureCoord);

                    gl.drawElements(gl.TRIANGLES, 12, type, offset);

//                    gl.bindBuffer(gl.ARRAY_BUFFER, this.frustum_verts);
//                    gl.vertexAttribPointer(
//                        this.programInfo.attribLocations.textureCoord,
//                        2,
//                        gl.FLOAT,
//                        false,
//                        0,
//                        0);
//                    gl.enableVertexAttribArray(
//                        this.programInfo.attribLocations.textureCoord);
//
//
//                    gl.bindBuffer(gl.ARRAY_BUFFER, this.frustum_vert_pos);
//                    gl.vertexAttribPointer(
//                        this.programInfo.attribLocations.vertexPosition,
//                        3,
//                        gl.FLOAT,
//                        false,
//                        0,
//                        0);
//                    gl.enableVertexAttribArray(
//                        this.programInfo.attribLocations.vertexPosition);
//
//                    gl.bindBuffer(gl.ARRAY_BUFFER, this.frustum_verts);
//                    gl.vertexAttribPointer(
//                        this.programInfo.attribLocations.textureCoord,
//                        2,
//                        gl.FLOAT,
//                        false,
//                        0,
//                        0);
//                    gl.enableVertexAttribArray(
//                        this.programInfo.attribLocations.textureCoord);
//                    gl.bindTexture(gl.TEXTURE_2D, this.transparent_texture);
//                    gl.drawElements(gl.TRIANGLES, 12    , type, offset);




                }






                // start "frustum" calc


                // Update the rotation for the next draw

                return;
            }
        };

        function flv_load() {
            console.log('isSupported: ' + flvjs.isSupported());
            if (mediaSourceURL.className === '') {
                var url = document.getElementById('msURL').value;
    
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function (e) {
                    var mediaDataSource = JSON.parse(xhr.response);
                    flv_load_mds(mediaDataSource);
                }
                xhr.send();
            } else {
                var i;
                var mediaDataSource = {
                    type: 'flv'
                };
                for (i = 0; i < checkBoxFields.length; i++) {
                    var field = checkBoxFields[i];
                    /** @type {HTMLInputElement} */
                    var checkbox = document.getElementById(field);
                    mediaDataSource[field] = checkbox.checked;
                }
                mediaDataSource['url'] = document.getElementById('sURL').value;
                console.log('MediaDataSource', mediaDataSource);
                flv_load_mds(mediaDataSource);
            }
        }

        function flv_load_mds(mediaDataSource) {
            var element = document.getElementsByName('videoElement')[0];
            if (typeof player !== "undefined") {
                if (player != null) {
                    player.unload();
                    player.detachMediaElement();
                    player.destroy();
                    player = null;
                }
            }
            player = flvjs.createPlayer(mediaDataSource, {
                enableWorker: false,
                lazyLoad: false,
                lazyLoadRecoverDuration: 0,
		cors: false,
                seekType: 'param',
            });
            player.attachMediaElement(element);
            player.load();
            processor.doLoad();
        }

        function flv_start() {
            player.play();
        }

        function flv_pause() {
            player.pause();
        }

        function flv_destroy() {
            var audio = player._getAudio();
            audio.initPlayback(document.getElementsByName('videoElement')[0]);
        }

        function flv_seekto() {
            var input = document.getElementsByName('seekpoint')[0];
            player.currentTime = parseFloat(input.value);
        }

        function switch_url() {
            streamURL.className = '';
            mediaSourceURL.className = 'hidden';
            saveSettings();
        }

        function switch_mds() {
            streamURL.className = 'hidden';
            mediaSourceURL.className = '';
            saveSettings();
        }

        function ls_get(key, def) {
            try {
                var ret = localStorage.getItem('flvjs_demo.' + key);
                if (ret === null) {
                    ret = def;
                }
                return ret;
            } catch (e) {}
            return def;
        }

        function ls_set(key, value) {
            try {
                localStorage.setItem('flvjs_demo.' + key, value);
            } catch (e) {}
        }

        function saveSettings() {
            if (mediaSourceURL.className === '') {
                ls_set('inputMode', 'MediaDataSource');
            } else {
                ls_set('inputMode', 'StreamURL');
            }
            var i;
            for (i = 0; i < checkBoxFields.length; i++) {
                var field = checkBoxFields[i];
                /** @type {HTMLInputElement} */
                var checkbox = document.getElementById(field);
                ls_set(field, checkbox.checked ? '1' : '0');
            }
            var msURL = document.getElementById('msURL');
            var sURL = document.getElementById('sURL');
            ls_set('msURL', msURL.value);
            ls_set('sURL', sURL.value);
            console.log('save');
        }

        function loadSettings() {
            var i;
            for (i = 0; i < checkBoxFields.length; i++) {
                var field = checkBoxFields[i];
                /** @type {HTMLInputElement} */
                var checkbox = document.getElementById(field);
                var c = ls_get(field, checkbox.checked ? '1' : '0');
                checkbox.checked = c === '1' ? true : false;
            }

            var msURL = document.getElementById('msURL');
            var sURL = document.getElementById('sURL');
            msURL.value = ls_get('msURL', msURL.value);
            sURL.value = ls_get('sURL', sURL.value);
            if (ls_get('inputMode', 'StreamURL') === 'StreamURL') {
                switch_url();
            } else {
                switch_mds();
            }
        }

        function showVersion() {
            var version = flvjs.version;
            document.title = document.title + " (v" + version + ")";
        }

        var logcatbox = document.getElementsByName('logcatbox')[0];
        flvjs.LoggingControl.addLogListener(function(type, str) {
            logcatbox.value = logcatbox.value + str + '\n';
            logcatbox.scrollTop = logcatbox.scrollHeight;
        });

        document.addEventListener('DOMContentLoaded', function () {
            streamURL = document.getElementById('streamURL');
            mediaSourceURL = document.getElementById('mediaSourceURL');
            loadSettings();
            showVersion();
            flv_load();
        });
    </script>
    
</body>

</html>
